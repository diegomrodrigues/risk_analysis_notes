### Simula√ß√µes de Monte Carlo com uma Vari√°vel Aleat√≥ria: Modelagem Din√¢mica de Drift e Volatilidade

### Introdu√ß√£o
Nos cap√≠tulos anteriores, exploramos a simula√ß√£o de trajet√≥rias de pre√ßos utilizando o m√©todo de Monte Carlo, com √™nfase no Movimento Browniano Geom√©trico (GBM) e no impacto do n√∫mero de passos na precis√£o [^3, 4]. At√© o momento, assumimos que os par√¢metros $\mu$ (drift) e $\sigma$ (volatilidade) s√£o constantes ao longo do tempo. No entanto, essa premissa pode ser irrealista em muitos cen√°rios financeiros, onde a taxa de retorno esperada e a volatilidade podem variar significativamente ao longo do tempo [^4]. Esta se√ß√£o se aprofunda na modelagem din√¢mica de $\mu$ e $\sigma$, explorando como incorporar processos como o GARCH para capturar a varia√ß√£o temporal desses par√¢metros [^4].

### Conceitos Fundamentais

A Equa√ß√£o (12.1) representa o GBM com $\mu$ e $\sigma$ constantes:

$$
dS_t = \mu S_t dt + \sigma S_t dz \qquad (12.1)
$$

Na realidade, tanto a taxa de retorno esperada quanto a volatilidade podem ser influenciadas por uma variedade de fatores econ√¥micos e de mercado, como taxas de juros, infla√ß√£o, not√≠cias corporativas e eventos geopol√≠ticos [^4]. Para capturar essa din√¢mica, podemos modelar $\mu$ e $\sigma$ como fun√ß√µes do tempo ou de vari√°veis passadas [^4].

**Modelagem Din√¢mica do Drift ($\mu$)**

O drift, $\mu$, representa a taxa de retorno esperada do ativo. Em alguns casos, pode ser razo√°vel assumir que $\mu$ √© constante, especialmente em horizontes de tempo curtos [^3]. No entanto, em horizontes mais longos, ou quando se considera ativos com retornos mais previs√≠veis (e.g., t√≠tulos indexados √† infla√ß√£o), √© importante modelar a varia√ß√£o de $\mu$. Uma abordagem simples √© modelar $\mu$ como uma fun√ß√£o determin√≠stica do tempo:

$$
\mu_t = f(t)
$$

Onde $f(t)$ pode ser uma fun√ß√£o linear, polinomial ou qualquer outra fun√ß√£o que capture a tend√™ncia da taxa de retorno esperada ao longo do tempo.

> üí° **Exemplo Num√©rico:**
> Suponha que modelamos a taxa de retorno esperada como uma fun√ß√£o linear do tempo: $\mu_t = \mu_0 + \alpha t$, onde $\mu_0$ √© a taxa de retorno esperada inicial e $\alpha$ √© a taxa de varia√ß√£o da taxa de retorno esperada. Se $\mu_0 = 0.05$ e $\alpha = 0.01$, ent√£o a taxa de retorno esperada no tempo $t=1$ ano seria $\mu_1 = 0.05 + 0.01 \times 1 = 0.06$. Isso significa que esperamos que a taxa de retorno esperada aumente 1% ao ano.
>
> Ao implementar essa modelagem em uma simula√ß√£o de Monte Carlo, substituir√≠amos $\mu$ por $\mu_t$ na Equa√ß√£o (12.2) ou (12.3), atualizando o valor de $\mu$ em cada passo de tempo.

Uma abordagem mais sofisticada √© modelar $\mu$ como uma fun√ß√£o de vari√°veis passadas, incorporando informa√ß√µes sobre o estado da economia ou do mercado. Por exemplo, $\mu$ pode ser modelado como uma fun√ß√£o da taxa de juros, do spread de cr√©dito ou de outros indicadores econ√¥micos. Para ilustrar, podemos considerar um modelo simples onde $\mu_t$ √© uma fun√ß√£o linear da taxa de juros $r_t$:

$$
\mu_t = a + b r_t
$$

onde $a$ e $b$ s√£o par√¢metros a serem estimados. Nesse caso, a simula√ß√£o de Monte Carlo envolveria tamb√©m a simula√ß√£o da evolu√ß√£o da taxa de juros $r_t$ ao longo do tempo.

> üí° **Exemplo Num√©rico:**
> Vamos supor que temos dados hist√≥ricos da taxa de retorno de um ativo e da taxa de juros. Ap√≥s ajustar um modelo de regress√£o linear, encontramos que $a = 0.02$ e $b = 0.5$. Isso significa que, em m√©dia, para cada aumento de 1% na taxa de juros, a taxa de retorno esperada do ativo aumenta 0.5%.
>
> Para simular a taxa de retorno esperada ao longo do tempo, precisar√≠amos simular a evolu√ß√£o da taxa de juros. Podemos usar um modelo simples como um processo de Ornstein-Uhlenbeck:
> $$dr_t = \kappa(\theta - r_t)dt + \sigma_r dz_t$$
> onde $\kappa$ √© a velocidade de revers√£o √† m√©dia, $\theta$ √© o n√≠vel m√©dio da taxa de juros, $\sigma_r$ √© a volatilidade da taxa de juros e $dz_t$ √© um incremento de um processo de Wiener.
>
> Suponha que $\kappa = 0.2$, $\theta = 0.04$, $\sigma_r = 0.01$ e a taxa de juros inicial √© $r_0 = 0.03$. Podemos simular a trajet√≥ria da taxa de juros e, em seguida, usar essa trajet√≥ria para calcular a taxa de retorno esperada $\mu_t$ em cada passo de tempo.
>
> ```python
> import numpy as np
> import matplotlib.pyplot as plt
>
> # Par√¢metros
> kappa = 0.2
> theta = 0.04
> sigma_r = 0.01
> r0 = 0.03
> T = 1
> n = 252
> dt = T / n
>
> # Simula√ß√£o da taxa de juros
> np.random.seed(42)
> r = np.zeros(n + 1)
> r[0] = r0
> for i in range(1, n + 1):
>     dr = kappa * (theta - r[i - 1]) * dt + sigma_r * np.sqrt(dt) * np.random.normal(0, 1)
>     r[i] = r[i - 1] + dr
>
> # C√°lculo da taxa de retorno esperada
> a = 0.02
> b = 0.5
> mu = a + b * r
>
> # Plot da taxa de juros e da taxa de retorno esperada
> fig, ax1 = plt.subplots(figsize=(10, 6))
>
> color = 'tab:red'
> ax1.set_xlabel('Tempo')
> ax1.set_ylabel('Taxa de Juros', color=color)
> ax1.plot(r, color=color)
> ax1.tick_params(axis='y', labelcolor=color)
>
> ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis
>
> color = 'tab:blue'
> ax2.set_ylabel('Taxa de Retorno Esperada', color=color)  # we already handled the x-label with ax1
> ax2.plot(mu, color=color)
> ax2.tick_params(axis='y', labelcolor=color)
>
> fig.tight_layout()  # otherwise the right y-label is slightly clipped
> plt.title('Simula√ß√£o da Taxa de Juros e da Taxa de Retorno Esperada')
> plt.show()
> ```
>
> O c√≥digo simula a taxa de juros usando o modelo de Ornstein-Uhlenbeck e, em seguida, usa a trajet√≥ria simulada para calcular a taxa de retorno esperada. O gr√°fico mostra a evolu√ß√£o da taxa de juros e da taxa de retorno esperada ao longo do tempo.

**Teorema 1** (Modelagem de $\mu$ com Regress√£o Linear): Se $\mu_t$ √© modelado como uma regress√£o linear de $k$ vari√°veis $x_{1,t}, x_{2,t}, \dots, x_{k,t}$, ou seja, $\mu_t = a_0 + \sum_{i=1}^{k} a_i x_{i,t}$, ent√£o, para cada simula√ß√£o de Monte Carlo, √© necess√°rio simular as trajet√≥rias das vari√°veis $x_{i,t}$ al√©m do pre√ßo do ativo $S_t$.

*Proof Strategy:* A prova segue diretamente da defini√ß√£o de $\mu_t$ como uma fun√ß√£o das vari√°veis $x_{i,t}$. Para cada passo de tempo na simula√ß√£o de Monte Carlo, precisamos conhecer os valores de $x_{i,t}$ para calcular $\mu_t$. Portanto, precisamos simular as trajet√≥rias dessas vari√°veis.

**Prova do Teorema 1:**

I. Assumimos que $\mu_t$ √© modelado como uma regress√£o linear de $k$ vari√°veis $x_{1,t}, x_{2,t}, \dots, x_{k,t}$:
   $$\mu_t = a_0 + \sum_{i=1}^{k} a_i x_{i,t}$$
   onde $a_0, a_1, \dots, a_k$ s√£o coeficientes constantes.

II. Em uma simula√ß√£o de Monte Carlo, precisamos calcular o valor de $\mu_t$ em cada passo de tempo $t$.

III. Para calcular $\mu_t$, precisamos conhecer os valores das vari√°veis $x_{1,t}, x_{2,t}, \dots, x_{k,t}$ no tempo $t$.

IV. Se as vari√°veis $x_{i,t}$ n√£o s√£o constantes ou deterministicamente definidas em fun√ß√£o do tempo, precisamos simular suas trajet√≥rias ao longo do tempo para obter seus valores em cada passo $t$.

V. Portanto, para cada simula√ß√£o de Monte Carlo, √© necess√°rio simular as trajet√≥rias das vari√°veis $x_{i,t}$ al√©m do pre√ßo do ativo $S_t$. ‚ñ†

**Modelagem Din√¢mica da Volatilidade ($\sigma$)**

A volatilidade, $\sigma$, representa a incerteza nos retornos do ativo. Evid√™ncias emp√≠ricas sugerem que a volatilidade n√£o √© constante ao longo do tempo, mas sim clusters de volatilidade, onde per√≠odos de alta volatilidade tendem a ser seguidos por per√≠odos de alta volatilidade, e vice-versa [^4]. Para capturar essa din√¢mica, podemos utilizar modelos como os modelos GARCH (Generalized Autoregressive Conditional Heteroskedasticity) [^4]. Al√©m dos modelos GARCH, outros modelos de volatilidade estoc√°stica, como o modelo de Heston, tamb√©m podem ser utilizados.

**Modelos GARCH**

Os modelos GARCH s√£o uma classe de modelos estat√≠sticos que permitem que a volatilidade condicional (a volatilidade no momento *t*, condicionada √† informa√ß√£o dispon√≠vel no momento *t-1*) varie ao longo do tempo [^4]. A forma geral de um modelo GARCH(p, q) √©:

$$
\sigma_t^2 = \alpha_0 + \sum_{i=1}^{q} \alpha_i \epsilon_{t-i}^2 + \sum_{j=1}^{p} \beta_j \sigma_{t-j}^2
$$

Onde:

*   $\sigma_t^2$ √© a vari√¢ncia condicional no momento *t*.
*   $\alpha_0$ √© uma constante.
*   $\alpha_i$ s√£o os coeficientes dos termos ARCH (Autoregressive Conditional Heteroskedasticity), que capturam o impacto de choques passados na volatilidade atual.
*   $\epsilon_{t-i}^2$ s√£o os quadrados dos res√≠duos passados (os choques passados).
*   $\beta_j$ s√£o os coeficientes dos termos GARCH, que capturam a persist√™ncia da volatilidade.
*   $p$ √© a ordem do termo GARCH (o n√∫mero de termos de volatilidade passada inclu√≠dos no modelo).
*   $q$ √© a ordem do termo ARCH (o n√∫mero de termos de choque passado inclu√≠dos no modelo).

Um modelo GARCH(1, 1) √© frequentemente utilizado devido √† sua simplicidade e capacidade de capturar a din√¢mica da volatilidade [^4]:

$$
\sigma_t^2 = \alpha_0 + \alpha_1 \epsilon_{t-1}^2 + \beta_1 \sigma_{t-1}^2
$$

Neste caso, a volatilidade atual depende da volatilidade passada ($\sigma_{t-1}^2$) e do choque mais recente ($\epsilon_{t-1}^2$).

> üí° **Exemplo Num√©rico:**
> Suponha que estimamos um modelo GARCH(1, 1) para um determinado ativo e obtemos os seguintes coeficientes:
> $\alpha_0 = 0.00001$, $\alpha_1 = 0.1$, $\beta_1 = 0.8$.
> Se a volatilidade no momento $t-1$ √© $\sigma_{t-1} = 0.01$ (1%) e o choque mais recente √© $\epsilon_{t-1} = 0.02$ (2%), ent√£o a volatilidade no momento *t* √© calculada como:
> $\sigma_t^2 = 0.00001 + 0.1 \times (0.02)^2 + 0.8 \times (0.01)^2 = 0.00001 + 0.00004 + 0.00008 = 0.00013$
> Portanto, $\sigma_t = \sqrt{0.00013} \approx 0.0114$ (1.14%).
>
> Para incorporar o modelo GARCH em uma simula√ß√£o de Monte Carlo, precisar√≠amos atualizar o valor de $\sigma$ em cada passo de tempo, usando a Equa√ß√£o GARCH e os choques aleat√≥rios gerados.

**Lema 1.1** (Converg√™ncia do GARCH(1,1)): Para que o modelo GARCH(1,1) seja estacion√°rio e, portanto, √∫til em simula√ß√µes de longo prazo, a condi√ß√£o $\alpha_1 + \beta_1 < 1$ deve ser satisfeita.

*Proof Strategy:* A estacionariedade do modelo GARCH(1,1) implica que a vari√¢ncia incondicional √© finita e constante ao longo do tempo. A condi√ß√£o $\alpha_1 + \beta_1 < 1$ garante que a influ√™ncia dos choques passados na volatilidade diminui exponencialmente ao longo do tempo, evitando que a volatilidade exploda para o infinito.

**Prova do Lema 1.1:**

I. Considere o modelo GARCH(1,1):
   $$\sigma_t^2 = \alpha_0 + \alpha_1 \epsilon_{t-1}^2 + \beta_1 \sigma_{t-1}^2$$

II. Para que o modelo seja estacion√°rio, a vari√¢ncia incondicional $\mathbb{E}[\sigma_t^2]$ deve ser finita e constante.

III. Tomando a expectativa condicional em ambos os lados da equa√ß√£o:
    $$\mathbb{E}[\sigma_t^2] = \alpha_0 + \alpha_1 \mathbb{E}[\epsilon_{t-1}^2] + \beta_1 \mathbb{E}[\sigma_{t-1}^2]$$

IV. Assumindo que $\mathbb{E}[\sigma_t^2] = \mathbb{E}[\sigma_{t-1}^2] = \sigma^2$ e $\mathbb{E}[\epsilon_{t-1}^2] = \sigma_{\epsilon}^2$ (vari√¢ncia dos res√≠duos), temos:
    $$\sigma^2 = \alpha_0 + \alpha_1 \sigma_{\epsilon}^2 + \beta_1 \sigma^2$$

V. Reorganizando os termos:
    $$\sigma^2 (1 - \beta_1) = \alpha_0 + \alpha_1 \sigma_{\epsilon}^2$$

VI. Isolando $\sigma^2$:
     $$\sigma^2 = \frac{\alpha_0 + \alpha_1 \sigma_{\epsilon}^2}{1 - \beta_1}$$

VII. Para que $\sigma^2$ seja finita, o denominador deve ser diferente de zero e positivo.  Como $\alpha_0$ e $\alpha_1 \sigma_{\epsilon}^2$ s√£o positivos,  $1 - \beta_1 > 0$ √© necess√°rio.

VIII. Para garantir que a vari√¢ncia condicional seja finita e constante no longo prazo, precisamos que a influ√™ncia dos choques passados na volatilidade diminua ao longo do tempo. Isso implica que $\alpha_1 + \beta_1 < 1$. Se essa condi√ß√£o n√£o for satisfeita, a volatilidade pode explodir para o infinito, tornando o modelo inadequado para simula√ß√µes de longo prazo. ‚ñ†

> üí° **Exemplo Num√©rico (An√°lise da Condi√ß√£o de Estacionariedade):**
> Usando os par√¢metros do exemplo anterior ($\alpha_1 = 0.1$, $\beta_1 = 0.8$), podemos verificar a condi√ß√£o de estacionariedade:
> $\alpha_1 + \beta_1 = 0.1 + 0.8 = 0.9 < 1$.
>
> Como a soma dos coeficientes √© menor que 1, o modelo GARCH(1,1) √© estacion√°rio e pode ser usado em simula√ß√µes de longo prazo. Se, por outro lado, tiv√©ssemos $\alpha_1 = 0.3$ e $\beta_1 = 0.8$, ent√£o $\alpha_1 + \beta_1 = 1.1 > 1$, e o modelo n√£o seria estacion√°rio. Nesse caso, a volatilidade tenderia a explodir ao longo do tempo, tornando a simula√ß√£o inst√°vel e irrealista.

**Implementa√ß√£o da Modelagem Din√¢mica em Simula√ß√µes de Monte Carlo**

Para incorporar a modelagem din√¢mica de $\mu$ e $\sigma$ em simula√ß√µes de Monte Carlo, os seguintes passos s√£o necess√°rios:

1.  **Estimar os par√¢metros dos modelos para $\mu$ e $\sigma$:** Isso pode ser feito utilizando dados hist√≥ricos de retornos e outras vari√°veis relevantes.
2.  **Inicializar os valores de $\mu$ e $\sigma$ com seus valores atuais.**
3.  **Em cada passo de tempo da simula√ß√£o:**
    a.  Atualizar os valores de $\mu$ e $\sigma$ usando as equa√ß√µes dos modelos din√¢micos.
    b.  Gerar um n√∫mero aleat√≥rio $\epsilon$ a partir de uma distribui√ß√£o normal padr√£o.
    c.  Calcular a varia√ß√£o do pre√ßo $\Delta S_t$ usando a Equa√ß√£o (12.2), substituindo $\mu$ e $\sigma$ por seus valores atualizados.
    d.  Atualizar o pre√ßo $S_t$.
4.  **Repetir o passo 3 at√© atingir o horizonte de tempo desejado.**

**Corol√°rio 3.1** A incorpora√ß√£o de modelos din√¢micos para $\mu$ e $\sigma$ aumenta a complexidade computacional da simula√ß√£o de Monte Carlo. No entanto, pode resultar em uma representa√ß√£o mais realista do comportamento do pre√ßo do ativo e, consequentemente, em uma estimativa mais precisa das medidas de risco.

**Prova do Corol√°rio 3.1:**

I. Modelos din√¢micos para $\mu$ e $\sigma$ (como modelos GARCH) exigem a atualiza√ß√£o desses par√¢metros em cada passo de tempo da simula√ß√£o.

II. A atualiza√ß√£o de $\mu$ e $\sigma$ envolve c√°lculos adicionais, como a avalia√ß√£o das equa√ß√µes do modelo din√¢mico (e.g., a equa√ß√£o GARCH) e a simula√ß√£o de vari√°veis adicionais (como taxas de juros, se $\mu$ depender delas).

III. Esses c√°lculos adicionais aumentam o tempo de computa√ß√£o necess√°rio para completar cada simula√ß√£o de Monte Carlo.

IV. No entanto, ao modelar a varia√ß√£o temporal de $\mu$ e $\sigma$, capturamos caracter√≠sticas importantes do comportamento do pre√ßo do ativo que n√£o seriam capturadas com modelos est√°ticos.

V. Essa representa√ß√£o mais realista do comportamento do pre√ßo do ativo pode levar a uma estimativa mais precisa das medidas de risco, como o Value at Risk (VaR) e o Expected Shortfall (ES).

VI. Portanto, a incorpora√ß√£o de modelos din√¢micos aumenta a complexidade computacional, mas pode resultar em estimativas de risco mais precisas. ‚ñ†

> üí° **Exemplo Num√©rico (Implementa√ß√£o em Python com GARCH(1,1)):** O c√≥digo a seguir demonstra como implementar a simula√ß√£o de trajet√≥rias de pre√ßos com um modelo GARCH(1,1) para a volatilidade. Para simplificar, mantemos o drift $\mu$ constante:
>
> ```python
> import numpy as np
> from scipy.stats import norm
> import matplotlib.pyplot as plt
> 
> # Par√¢metros
> S0 = 100      # Pre√ßo inicial
> mu = 0.05     # Taxa de retorno esperada (constante)
> T = 1         # Horizonte de tempo (anos)
> n = 252       # N√∫mero de passos
> dt = T / n    # Tamanho do passo
> 
> # Par√¢metros GARCH(1,1)
> alpha0 = 0.00001
> alpha1 = 0.1
> beta1 = 0.8
> 
> # N√∫mero de simula√ß√µes
> num_simulations = 10
> 
> # Simula√ß√£o de Monte Carlo com GARCH
> np.random.seed(42) # Para reprodutibilidade
> 
> plt.figure(figsize=(10, 6))
> 
> for j in range(num_simulations):
>  # Inicializa√ß√£o da volatilidade
>  sigma = 0.2 # Volatilidade inicial
>  sigma_values = np.zeros(n+1)
>  sigma_values[0] = sigma
> 
>  S = np.zeros(n+1)
>  S[0] = S0
> 
>  for i in range(1, n+1):
>      # Gera√ß√£o do choque aleat√≥rio
>      epsilon = np.random.normal(0, 1)
> 
>      # Atualiza√ß√£o da volatilidade com GARCH(1,1)
>      sigma2 = alpha0 + alpha1 * epsilon**2 + beta1 * sigma**2
>      sigma = np.sqrt(sigma2)
> 
>      # C√°lculo da varia√ß√£o do pre√ßo
>      St = S[i-1] * np.exp((mu - 0.5 * sigma**2) * dt + sigma * epsilon * np.sqrt(dt))
>      S[i] = St
> 
>      sigma_values[i] = sigma
> 
>  # Plot da trajet√≥ria do pre√ßo
>  plt.plot(S)
> 
> plt.xlabel("Passo")
> plt.ylabel("Pre√ßo")
> plt.title("Simula√ß√£o de Trajet√≥rias de Pre√ßo (GBM com GARCH(1,1))")
> plt.grid(True)
> plt.show()
> 
> # Plot da volatilidade ao longo do tempo
> plt.plot(sigma_values)
> plt.xlabel("Passo")
> plt.ylabel("Volatilidade")
> plt.title("Volatilidade GARCH(1,1) ao longo do tempo")
> plt.grid(True)
> plt.show()
> 
> ```
>
> O c√≥digo estima a trajet√≥ria de pre√ßo usando o modelo GBM, mas atualiza a volatilidade a cada passo usando a equa√ß√£o do GARCH(1,1). Este modelo incorpora o efeito do *clustering* de volatilidade. A escolha de *alpha0*, *alpha1* e *beta1* definem o n√≠vel base da volatilidade, a rea√ß√£o a choques, e a persist√™ncia dos choques na volatilidade.
>
> ![teste](./../images/figure1.jpg)
>
> ![GARCH(1,1) Price Simulation](./../images/figure2.jpg)
>
> üí° **Exemplo Num√©rico (Compara√ß√£o com Modelo de Volatilidade Constante):** Para demonstrar o impacto da modelagem GARCH, podemos comparar os resultados da simula√ß√£o com um modelo de volatilidade constante. Suponha que a volatilidade m√©dia hist√≥rica do ativo seja de 20%. Podemos executar a mesma simula√ß√£o de Monte Carlo, mas com $\sigma = 0.2$ constante ao longo do tempo. Ao comparar as trajet√≥rias de pre√ßos e a distribui√ß√£o dos pre√ßos finais obtidas com os dois modelos, podemos observar que o modelo GARCH captura a din√¢mica da volatilidade e gera trajet√≥rias de pre√ßos mais realistas, com per√≠odos de alta e baixa volatilidade. A distribui√ß√£o dos pre√ßos finais com o modelo GARCH tamb√©m pode ser diferente, com caudas mais pesadas devido aos clusters de alta volatilidade.
>
> ```python
> import numpy as np
> from scipy.stats import norm
> import matplotlib.pyplot as plt
> 
> # Par√¢metros
> S0 = 100      # Pre√ßo inicial
> mu = 0.05     # Taxa de retorno esperada (constante)
> T = 1         # Horizonte de tempo (anos)
> n = 252       # N√∫mero de passos
> dt = T / n    # Tamanho do passo
> 
> # Modelo de Volatilidade Constante
> sigma_const = 0.2
> 
> # Par√¢metros GARCH(1,1)
> alpha0 = 0.00001
> alpha1 = 0.1
> beta1 = 0.8
> 
> # N√∫mero de simula√ß√µes
> num_simulations = 1000
> 
> # Simula√ß√£o de Monte Carlo com Volatilidade Constante
> np.random.seed(42) # Para reprodutibilidade
> 
> S_const = np.zeros((num_simulations, n+1))
> S_const[:, 0] = S0
> 
> for j in range(num_simulations):
>  for i in range(1, n+1):
>      epsilon = np.random.normal(0, 1)
>      St = S_const[j, i-1] * np.exp((mu - 0.5 * sigma_const**2) * dt + sigma_const * epsilon * np.sqrt(dt))
>      S_const[j, i] = St
> 
> # Simula√ß√£o de Monte Carlo com GARCH
> S_garch = np.zeros((num_simulations, n+1))
> S_garch[:, 0] = S0
> 
> for j in range(num_simulations):
>  sigma = 0.2 # Volatilidade inicial
>  for i in range(1, n+1):
>      epsilon = np.random.normal(0, 1)
>      sigma2 = alpha0 + alpha1 * epsilon**2 + beta1 * sigma**2
>      sigma = np.sqrt(sigma2)
>      St = S_garch[j, i-1] * np.exp((mu - 0.5 * sigma**2) * dt + sigma * epsilon * np.sqrt(dt))
>      S_garch[j, i] = St
> 
> # Plot da distribui√ß√£o dos pre√ßos finais
> plt.figure(figsize=(12, 6))
> plt.hist(S_const[:, -1], bins=50, alpha=0.5, label='Volatilidade Constante')
> plt.hist(S_garch[:, -1], bins=50, alpha=0.5, label='GARCH(1,1)')
> plt.xlabel("Pre√ßo Final")
> plt.ylabel("Frequ√™ncia")
> plt.title("Distribui√ß√£o dos Pre√ßos Finais (Volatilidade Constante vs. GARCH(1,1))")
> plt.legend()
> plt.grid(True)
> plt.show()
> 
> # Estat√≠sticas Descritivas
> print("Volatilidade Constante: M√©dia =", np.mean(S_const[:, -1]), ", Desvio Padr√£o =", np.std(S_const[:, -1]))
> print("GARCH(1,1): M√©dia =", np.mean(S_garch[:, -1]), ", Desvio Padr√£o =", np.std(S_garch[:, -1]))
> ```
>
> Este c√≥digo compara a distribui√ß√£o dos pre√ßos finais obtidos com um modelo de volatilidade constante e um modelo GARCH(1,1). A diferen√ßa nas distribui√ß√µes e nas estat√≠sticas descritivas (m√©dia e desvio padr√£o) ilustra o impacto da modelagem din√¢mica da volatilidade.

### Conclus√£o

A modelagem din√¢mica de $\mu$ e $\sigma$ √© crucial para simula√ß√µes de Monte Carlo mais realistas e precisas [^4]. A incorpora√ß√£o de processos como o GARCH permite capturar a varia√ß√£o temporal da volatilidade, que √© uma caracter√≠stica importante dos mercados financeiros [^4]. Embora a modelagem din√¢mica aumente a complexidade computacional, os benef√≠cios em termos de precis√£o das estimativas de risco podem superar os custos [^4]. As se√ß√µes subsequentes do cap√≠tulo explorar√£o outras t√©cnicas para melhorar a precis√£o e efici√™ncia das simula√ß√µes de Monte Carlo, incluindo m√©todos para gerar n√∫meros aleat√≥rios de alta qualidade, modelar m√∫ltiplas vari√°veis com correla√ß√µes, e acelerar os c√°lculos [^6, 15, 17, 18, 19].

### Refer√™ncias
[^3]: Se√ß√£o 12.2.1: Simulating a Price Path.
[^4]: Cap√≠tulo 12: Monte Carlo Methods.
[^6]: Se√ß√£o 12.2.2: Creating Random Numbers.
[^15]: Se√ß√£o 12.4: Simulations with Multiple Variables.
[^17]: Se√ß√£o 12.3.2: Acceleration Methods.
[^18]: Se√ß√£o 12.5: Deterministic Simulation.
[^19]: Figura 12-4.
<!-- END -->